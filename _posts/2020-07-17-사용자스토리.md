

# 1장 개요

비즈니스와 개발자간의 힘의 균형을 유지하기 위한 의사소통 수단이 필요하다.

프로젝트가 어떻게 진행될지 완벽하게 예측할 수 없기 때문에, 프로젝트 착수 시점에 모든 것을 포괄하는 결정을 하기 보다는 프로젝트 전 기간에 걸쳐 가능한 자주, 신속한 의사 결정을 지원하는 프로세스가 필요하다.

#### 사용자 스토리란 무엇인가?

사용자 스토리는 고객에게 가치를 줄 수 있는 기능을 서술한 것이다. 세 측면으로 구성된다.

- 카드(card)/서술(written description) : 스토리는 서술형으로, 계획 혹은 기억하기 위한 단서
- 대화(conversation) : 스토리는 대화를 통해 세부사항을 구체화
- 확인(Confirmation)/테스트(test) : 스토리는 테스트를 통해 세부사항을 문서화, 스토리 완료 여부를 판단

**'카드'는 스토리의 본문(text)을 담고있지만, 세부사항은 '대화'를 통해 결정되며 구현을 '확인'하기 위한 테스트를 포함한다.**

사용자 스토리는 고객에게 **가치를 평가** 받을 수 있도록 기능을 표현해야 한다.

* 사용자는 채용 정보를 검색할 수 있다. (O), 기업은 채용 정보를 게시할 수 있다. (O)
* 소프트웨어는 C++로 작성한다. (X), 프로그램은 커넥션풀을 통해 데이터베이스에 연결한다.(X)

*시사점: 모듈의 요구 사항을 기능 단위로 기술한다면 ,가치를 평가 받을 수 있는 사용자 스토리에  보다가까울 것 같다. 모듈의 요구 사항의 목적은 테스트인가? 아니면 다른 이해관계자들과의 커뮤니케이션인가?*

#### 세부사항은 어디에 있는가?

스토리가 너무 큰 경우에 '에픽(epic)' 이라고 하고, story는 한두 명의 개발자가 반나절, **길어도 2주일 안에 구현하고 테스트 할 수 있는 정도의 크기**가 적당하다.

- 사용자는 채용 정보를 검색할 수 있다. (epic)
  - 사용자는 위치, 급여 수준, 직업 명 등의 속성값으로 채용 정보를 검색할 수 있다. (story)
  - 사용자는 검색 조건과 일치하는 채용 정보를 볼 수 있다. (story)
  - 사용자는 채용 정보를 게시한 기업에 대한 세부 정보를 볼 수 있다. (story)

보다 구체적인 세부사항들은 개발팀과 고객이 논의하고 합의하는 것이 더 낫다. 합의된 내용은 스토리가 정확하게 개발되었는지를 증명하는 테스트 형태로 문서화된다. 

* 스토리는 전형적인 요구사항 문서 처럼 계약과 같은 구속이 되어서는 안된다. 대화를 위해 기억하기 위한 단서로 활용되어야 한다.

#### 얼마나 길어야 하나요?

인수 테스트(acceptance test)를 위해 테스트가 사용된다. 이과정의 목적은 스토리에 대한 부가 정보를 통해 개발자가 고객의 기대 수준에 맞게 자기일을 끝냈다는 것을 알 수 있도록 하는 것이다.

#### 고객팀

전지전능한 한사람은 없기에, 고객 팀을 구성한다.

테스터, 제품 관리자, 실제 사용자, 상호작용 설계자(interaction designeer) 등이 포함된다.

#### 왜 고객이 스토리를 작성하는가?

- 스토리는 기술적 전문 용어가 아닌 비즈니스 언어로 작성해야 한다. 그래야 고객 팀에서 스토리를 어느 이터레이션이나 릴리즈에 포함 시킬지 우선 순위를 정할 수 있다. 
- 제품의 주된 기획 주체로서 고객팀이 제품의 동작을 가장 잘 설명할 수 있다.

#### 프로세스는 어떤 모습인가?

폭포수 방식의 프로세스는 요구사항 분석 단계와 인수 단계 사이의 과정에 고객이 참여하는 일은 거의 없다. 

스토리 주도(stroy-driven) 프로젝트에서는 고객이 프로젝트를 하는 기간 내내 계속 참여한다.

- 여러 사용자 유형을 고려하고, 가급적 많은 사용자 유형을 대표할 수 있는 사람들이 고객팀에 포함한다.
- 스토리 작성 워크숍 등을 통해 브레인스토밍을 거쳐 가능한 많은 스토리를 찾는다.
- 초기 스토리가 마련되면 개발자는 각각의 크기를 추정한다.
- 이터레이션 길이를 선택한다. (1 ~ 4주)
  - 개발자는 이터레이션마다 소프트웨어의 일부 기능이라도 그 자체로 쓸모 있는 코드를 인도해야할 책임이 있다.
  - 고객 팀은 이터레이션 기간동안 긴밀히 참여하여, 개발자와 해당 이터레이션에서 개발하는 스토리에 대한 대화를 나누고, 테스트할 것을 지정하여 개발자와 함께 테스트를 자동화하고 실행한다. 추가로 프로젝트가 올바른 방향으로 꾸준히 나아가는지 확인한다.
- 개발자는 이터레이션마다 얼만큼 일을 할 수 있는지 추정한다. '속도(velocity)' 라고 부른다.
  - 미리 알 수 없으므로, 초기 추정 속도는 틀릴 것이다. 그럼에도 초기 추정치를 이용하여 릴리즈 계획(release plan)을 세운다.
  - 스토리들을 여러 묶음으로 분류하여 각 이터레이션에 할당한다. 
    - 각 묶음에 포함된 스토리의 추정치는 속도 추정치를 넘지 않도록 한다.
    - 우선순위가 높은 스토리들 부터 묶어서 먼저 배치한다.
- 각 이터레이션을 시작하기 전에 고객 팀은 진행 중인 릴리즈 계획을 수정할 수 있다. 
  - 한 이터레이션이 끝나면 개발 팀의 실제 속도를 알게되며, 실제 속도로 계획을 세운다.

*시사점: 초기 단계에서 추정 속도로 계획하고, 이터레이션이 진행됨에 따라 실제 속도를 계산하여 재계획하라!! 만일 추정 속도보다 실제 속도가 떨어진다면 자원을 재할당을 하거나, 우선순위 낮은 스토리는 릴리즈에서 제외한다.*

#### 릴리즈와 이터레이션 계획하기

* 릴리즈 계획(release planning) : 프로젝트 일정과 구현할 기능 집합의 균형을 결정한다.
  * 고객 팀이 스토리에 우선순위를 매긴다. 우선순위 고려사항은 아래와 같다. 
    * 고객 다수가 원하는 기능인가?
    * 다수는 아니지만 중요한 고객이 바라는 기능인가?
    * 이 스토리가 다른 스토리들과 응집성이 있는가?
  * 개발자는 우선순위를 매길 때는 기술적 리스크나 다른 스토리와의 상호 보완성을 고려해려고 한다. 고객 팀은 우선순위를 매길 때에 개발자의 목소리를 들어야 하지만 **조직에 최대의 가치**를 가져오도록 신경써야 한다.
  * 우선순위를 부여할 때 스토리의 개발 비용도 고려하지 않을 수 없다.
    * 스토리 개발 비용은 스토리에 부여하는 추정치로 각 스토리에 스토리 점수(story point)를 추정치로 할당한다.
  * 릴리즈 계획은 릴리즈에 포함된 각 이터레이션에 스토리들을 할당함으로써 수립된다.
    * 개발자는 자신의 속도를 얘기하고, 고객은 스토리 묶음을 각 이터레이션에 배치한다. 
    * 어떤 이터레이션도 할당된 스토리 점수의 합이 팀 전체의 속도 추정치를 넘지 않게 한다.
    * 우선순위에 따라 이터레이션에 배치할때 스토리 점수가 속도를 넘으면, 큰 스토리를 건너 뛰고 작은 스토리를 먼저 배치하거나, 큰 스토리를 작은 스토리로 나누는 방법이 있다. 
* 이터레이션 계획(iteration planning) : 이번 이터레이션에 포함할 스토리를 선택한다.

*시사점: 상위 수준 설계시에는 아키텍트가 고객의 역할을 해야 한다. 개별 모듈 담당자에게 스토리를 할당하고 우선순위를 결정해준다.*

#### 인수 테스트는 무엇인가?

인수 테스트는 스토리 개발한 뒤 그것이 고객이 기대하는 대로 정확히 동작하는지를 입증하는 과정이다.

이터레이션이 시작되면 개발자는 코드를 작성하고, 고객팀은 테스트를 작성한다. (고객팀에는 숙련된 테스터가 포함되어야 한다.)

가급적 테스트는 각 이터레이션의 초기에 작성한다. 심지어 이터레이션을 시작하기 전에 작성할 수도 있다.

- 초기에 테스트를 작성하면 고객이 가정과 기대사항을 더 많이 더 빨리 개발자에게 전달 할 수 있다.

#### 왜 바꾸어야 하는가?

- 사용자 스토리는 문서보다 구두 의사소통을 강조한다.
  - 잘 읽지도 않을 문서에 중요한 결정사항을 남기지 않는다. 오히려 자동화된 인수 테스트로 정의하여 자주 실행하게 한다.
- 사용자 스토리는 고객이나 개발자 모두 이해할 수 있다.
  - 기술용어를 사용하지 않으므로, 고객은 물론 개발자도 이해할 수 있다.
- 사용자 스토리는 계획 수립에 적당한 크기이다.
  - 각 사용자 스토리는 개별적 단위 기능(사용자가 특정 환경에서 수행 할 수 있는)이어서, 계획을 수립할 때 유리하다.
- 사용자 스토리는 반복적 개발(iterative development)에 효과적이다.
  - 반복적 프로세스는 연속적인 refinement로 발전해 간다.
  - 개발 팀은 일부 불완전한 영역을 가지고 첫 개발을 시작한다. 제품이 만족스러울 때까지 불완전한 영역을 계속 다듬어 간다. 이터레이션 마다 더 많은 세부사항들이 추가되면서 개선 된다.
  - 사용자 스토리를 반복적으로 다듬으면서 진행할 수 있다. 
  - 최종적으로 필요하지만 당장은 중요하지 않은 기능을 처음에는 에픽으로 골격만 작성해 두었다가, 정말 그 기능이 시스템에 추가될 준비가 되었을 때, 스토리를 다듬고 세부사항을 더하여, 에픽을 더 작은 스토리들로 나누어 대체 할 수 있다.
- 사용자 스토리는 무엇이 필요한지 잘 알 때가지 세부사항을 뒤로 미룰 수 있게 한다.
  - 당장은 에픽만 작성해 두고, 정말 그 부분을 개발할 필요가 있을 때까지 세부적인 내용 작성을 미룰 수 있다.

*시사점: 대부분이 개발에서, 특히 앱 개발시에는 초기에는 카드 수준의 컨셉만 있을 뿐이며, 세부 사항의 결정이 뒤로 지연될 때가 많다.  앱 개발은 어쩌면 반복적으로 refinement하는 과정 그 자체이다. 또한, UX, RM등 비개발자와 개발자간의 커뮤니케이션 오류에 가장 민감하기도 하다. 앱 개발에 사용자 스토리 프로세스를 적용한다면 최선의 효과를 거둘수 있지 않을까?*

# 2장. 스토리 작성하기

*시사점: INVEST 원칙은 사용자 스토리뿐만 아니라 모든 종류의 요구사항 적성에 유용해 보인다. 우리의 SRS에 작성을 위해서도 필요해 보인다. 스토리 작성하기 교육을 만들어 개발자들을 트레이닝할 필요가 있지 않은가?*

# 3장. 사용자 역할 모델링하기

*시사점: 사용자 역할 모델링은 모든 종류의 일에 필요하다. 예를 들어 간단한 문서를 만들 때에도 그 문서의 독자를 모델링 할 필요가 있다.*