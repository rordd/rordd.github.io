

# 1장 개요

비즈니스와 개발자간의 힘의 균형을 유지하기 위한 의사소통 수단이 필요하다.

프로젝트가 어떻게 진행될지 완벽하게 예측할 수 없기 때문에, 프로젝트 착수 시점에 모든 것을 포괄하는 결정을 하기 보다는 프로젝트 전 기간에 걸쳐 가능한 자주, 신속한 의사 결정을 지원하는 프로세스가 필요하다.

#### 사용자 스토리란 무엇인가?

사용자 스토리는 고객에게 가치를 줄 수 있는 기능을 서술한 것이다. 세 측면으로 구성된다.

- 카드(card)/서술(written description) : 스토리는 서술형으로, 계획 혹은 기억하기 위한 단서
- 대화(conversation) : 스토리는 대화를 통해 세부사항을 구체화
- 확인(Confirmation)/테스트(test) : 스토리는 테스트를 통해 세부사항을 문서화, 스토리 완료 여부를 판단

**'카드'는 스토리의 본문(text)을 담고있지만, 세부사항은 '대화'를 통해 결정되며 구현을 '확인'하기 위한 테스트를 포함한다.**

사용자 스토리는 고객에게 **가치를 평가** 받을 수 있도록 기능을 표현해야 한다.

* 사용자는 채용 정보를 검색할 수 있다. (O), 기업은 채용 정보를 게시할 수 있다. (O)
* 소프트웨어는 C++로 작성한다. (X), 프로그램은 커넥션풀을 통해 데이터베이스에 연결한다.(X)

*시사점: 모듈의 요구 사항을 기능 단위로 기술한다면 ,가치를 평가 받을 수 있는 사용자 스토리에  보다가까울 것 같다. 모듈의 요구 사항의 목적은 테스트인가? 아니면 다른 이해관계자들과의 커뮤니케이션인가?*

#### 세부사항은 어디에 있는가?

스토리가 너무 큰 경우에 '에픽(epic)' 이라고 하고, story는 한두 명의 개발자가 반나절, **길어도 2주일 안에 구현하고 테스트 할 수 있는 정도의 크기**가 적당하다.

- 사용자는 채용 정보를 검색할 수 있다. (epic)
  - 사용자는 위치, 급여 수준, 직업 명 등의 속성값으로 채용 정보를 검색할 수 있다. (story)
  - 사용자는 검색 조건과 일치하는 채용 정보를 볼 수 있다. (story)
  - 사용자는 채용 정보를 게시한 기업에 대한 세부 정보를 볼 수 있다. (story)

보다 구체적인 세부사항들은 개발팀과 고객이 논의하고 합의하는 것이 더 낫다. 합의된 내용은 스토리가 정확하게 개발되었는지를 증명하는 테스트 형태로 문서화된다. 

* 스토리는 전형적인 요구사항 문서 처럼 계약과 같은 구속이 되어서는 안된다. 대화를 위해 기억하기 위한 단서로 활용되어야 한다.

#### 얼마나 길어야 하나요?

인수 테스트(acceptance test)를 위해 테스트가 사용된다. 이과정의 목적은 스토리에 대한 부가 정보를 통해 개발자가 고객의 기대 수준에 맞게 자기일을 끝냈다는 것을 알 수 있도록 하는 것이다.

#### 고객팀

전지전능한 한사람은 없기에, 고객 팀을 구성한다.

테스터, 제품 관리자, 실제 사용자, 상호작용 설계자(interaction designeer) 등이 포함된다.

#### 왜 고객이 스토리를 작성하는가?

- 스토리는 기술적 전문 용어가 아닌 비즈니스 언어로 작성해야 한다. 그래야 고객 팀에서 스토리를 어느 이터레이션이나 릴리즈에 포함 시킬지 우선 순위를 정할 수 있다. 
- 제품의 주된 기획 주체로서 고객팀이 제품의 동작을 가장 잘 설명할 수 있다.

#### 프로세스는 어떤 모습인가?

폭포수 방식의 프로세스는 요구사항 분석 단계와 인수 단계 사이의 과정에 고객이 참여하는 일은 거의 없다. 

스토리 주도(stroy-driven) 프로젝트에서는 고객이 프로젝트를 하는 기간 내내 계속 참여한다.

- 여러 사용자 유형을 고려하고, 가급적 많은 사용자 유형을 대표할 수 있는 사람들이 고객팀에 포함한다.
- 스토리 작성 워크숍 등을 통해 브레인스토밍을 거쳐 가능한 많은 스토리를 찾는다.
- 초기 스토리가 마련되면 개발자는 각각의 크기를 추정한다.
- 이터레이션 길이를 선택한다. (1 ~ 4주)
  - 개발자는 이터레이션마다 소프트웨어의 일부 기능이라도 그 자체로 쓸모 있는 코드를 인도해야할 책임이 있다.
  - 고객 팀은 이터레이션 기간동안 긴밀히 참여하여, 개발자와 해당 이터레이션에서 개발하는 스토리에 대한 대화를 나누고, 테스트할 것을 지정하여 개발자와 함께 테스트를 자동화하고 실행한다. 추가로 프로젝트가 올바른 방향으로 꾸준히 나아가는지 확인한다.
- 개발자는 이터레이션마다 얼만큼 일을 할 수 있는지 추정한다. '속도(velocity)' 라고 부른다.
  - 미리 알 수 없으므로, 초기 추정 속도는 틀릴 것이다. 그럼에도 초기 추정치를 이용하여 릴리즈 계획(release plan)을 세운다.
  - 스토리들을 여러 묶음으로 분류하여 각 이터레이션에 할당한다. 
    - 각 묶음에 포함된 스토리의 추정치는 속도 추정치를 넘지 않도록 한다.
    - 우선순위가 높은 스토리들 부터 묶어서 먼저 배치한다.
- 각 이터레이션을 시작하기 전에 고객 팀은 진행 중인 릴리즈 계획을 수정할 수 있다. 
  - 한 이터레이션이 끝나면 개발 팀의 실제 속도를 알게되며, 실제 속도로 계획을 세운다.

*시사점: 초기 단계에서 추정 속도로 계획하고, 이터레이션이 진행됨에 따라 실제 속도를 계산하여 재계획하라!! 만일 추정 속도보다 실제 속도가 떨어진다면 자원을 재할당을 하거나, 우선순위 낮은 스토리는 릴리즈에서 제외한다.*

#### 릴리즈와 이터레이션 계획하기

* 릴리즈 계획(release planning) : 프로젝트 일정과 구현할 기능 집합의 균형을 결정한다.
  * 고객 팀이 스토리에 우선순위를 매긴다. 우선순위 고려사항은 아래와 같다. 
    * 고객 다수가 원하는 기능인가?
    * 다수는 아니지만 중요한 고객이 바라는 기능인가?
    * 이 스토리가 다른 스토리들과 응집성이 있는가?
  * 개발자는 우선순위를 매길 때는 기술적 리스크나 다른 스토리와의 상호 보완성을 고려해려고 한다. 고객 팀은 우선순위를 매길 때에 개발자의 목소리를 들어야 하지만 **조직에 최대의 가치**를 가져오도록 신경써야 한다.
  * 우선순위를 부여할 때 스토리의 개발 비용도 고려하지 않을 수 없다.
    * 스토리 개발 비용은 스토리에 부여하는 추정치로 각 스토리에 스토리 점수(story point)를 추정치로 할당한다.
  * 릴리즈 계획은 릴리즈에 포함된 각 이터레이션에 스토리들을 할당함으로써 수립된다.
    * 개발자는 자신의 속도를 얘기하고, 고객은 스토리 묶음을 각 이터레이션에 배치한다. 
    * 어떤 이터레이션도 할당된 스토리 점수의 합이 팀 전체의 속도 추정치를 넘지 않게 한다.
    * 우선순위에 따라 이터레이션에 배치할때 스토리 점수가 속도를 넘으면, 큰 스토리를 건너 뛰고 작은 스토리를 먼저 배치하거나, 큰 스토리를 작은 스토리로 나누는 방법이 있다. 
* 이터레이션 계획(iteration planning) : 이번 이터레이션에 포함할 스토리를 선택한다.

*시사점: 상위 수준 설계시에는 아키텍트가 고객의 역할을 해야 한다. 개별 모듈 담당자에게 스토리를 할당하고 우선순위를 결정해준다.*

#### 인수 테스트는 무엇인가?

인수 테스트는 스토리 개발한 뒤 그것이 고객이 기대하는 대로 정확히 동작하는지를 입증하는 과정이다.

이터레이션이 시작되면 개발자는 코드를 작성하고, 고객팀은 테스트를 작성한다. (고객팀에는 숙련된 테스터가 포함되어야 한다.)

가급적 테스트는 각 이터레이션의 초기에 작성한다. 심지어 이터레이션을 시작하기 전에 작성할 수도 있다.

- 초기에 테스트를 작성하면 고객이 가정과 기대사항을 더 많이 더 빨리 개발자에게 전달 할 수 있다.

#### 왜 바꾸어야 하는가?

- 사용자 스토리는 문서보다 구두 의사소통을 강조한다.
  - 잘 읽지도 않을 문서에 중요한 결정사항을 남기지 않는다. 오히려 자동화된 인수 테스트로 정의하여 자주 실행하게 한다.
- 사용자 스토리는 고객이나 개발자 모두 이해할 수 있다.
  - 기술용어를 사용하지 않으므로, 고객은 물론 개발자도 이해할 수 있다.
- 사용자 스토리는 계획 수립에 적당한 크기이다.
  - 각 사용자 스토리는 개별적 단위 기능(사용자가 특정 환경에서 수행 할 수 있는)이어서, 계획을 수립할 때 유리하다.
- 사용자 스토리는 반복적 개발(iterative development)에 효과적이다.
  - 반복적 프로세스는 연속적인 refinement로 발전해 간다.
  - 개발 팀은 일부 불완전한 영역을 가지고 첫 개발을 시작한다. 제품이 만족스러울 때까지 불완전한 영역을 계속 다듬어 간다. 이터레이션 마다 더 많은 세부사항들이 추가되면서 개선 된다.
  - 사용자 스토리를 반복적으로 다듬으면서 진행할 수 있다. 
  - 최종적으로 필요하지만 당장은 중요하지 않은 기능을 처음에는 에픽으로 골격만 작성해 두었다가, 정말 그 기능이 시스템에 추가될 준비가 되었을 때, 스토리를 다듬고 세부사항을 더하여, 에픽을 더 작은 스토리들로 나누어 대체 할 수 있다.
- 사용자 스토리는 무엇이 필요한지 잘 알 때가지 세부사항을 뒤로 미룰 수 있게 한다.
  - 당장은 에픽만 작성해 두고, 정말 그 부분을 개발할 필요가 있을 때까지 세부적인 내용 작성을 미룰 수 있다.

*시사점: 대부분이 개발에서, 특히 앱 개발시에는 초기에는 카드 수준의 컨셉만 있을 뿐이며, 세부 사항의 결정이 뒤로 지연될 때가 많다.  앱 개발은 어쩌면 반복적으로 refinement하는 과정 그 자체이다. 또한, UX, RM등 비개발자와 개발자간의 커뮤니케이션 오류에 가장 민감하기도 하다. 앱 개발에 사용자 스토리 프로세스를 적용한다면 최선의 효과를 거둘수 있지 않을까?*

# 2장. 스토리 작성하기

*시사점: INVEST 원칙은 사용자 스토리뿐만 아니라 모든 종류의 요구사항 적성에 유용해 보인다. 우리의 SRS에 작성을 위해서도 필요해 보인다. 스토리 작성하기 교육을 만들어 개발자들을 트레이닝할 필요가 있지 않은가?*

# 3장. 사용자 역할 모델링하기

*시사점: 사용자 역할 모델링은 모든 종류의 일에 필요하다. 예를 들어 간단한 문서를 만들 때에도 그 문서의 독자를 모델링 할 필요가 있다.*

# 4장. 스토리 수집하기 (Gethering Stories)

요구 사항을 수집하는 과정은 그물질(trawling)과 같다. 

- 1. 각기 다른 크기의 요구사항들을 잡아내기 위해 다른 크기의 그물을 사용한다.

  - 첫 단계에서는 성긴 그물을 이용해  큰 것들을 잡고, 다음 단계에서 조금 촘촘한 그물을 이용해 중간 크기를 잡아내며, 이것을 반복한다.
  - 릴리즈 계획시에는 성긴 그물로 정밀도가 낮은 개략적인 사용자 스토리를 작성하고, 시간축으로 촘촘한 그물로 구체적인 것을 작성한다.

- 2. 요구사항이 물고기처럼 성장하고 죽을 수도 있다. 각 이터레이션의 피드백을 통해 더 중요해지거나 덜 중요해질수 있다.

- 3. 물고기를 낚을 때 그 지역의 물고기를 모두 집지 못하는것 처럼 모든 요구사항을 찾아내지 못한다. 한편, 표류하는 잡동사니 쓰레기 등이 걸려 요구사항이 쓸데없이 부플 수도 있다.

- 4. 요구사항을 수집하는 것은 숙련된 기술이 중요한 역할을 한다. 

*시사점:  그물질이라는 메타포는 활용성이 높은 메타포로 보인다. 리스크 통제나 우선순위 기반의 업무를 설명하는데도 유용할 듯 하다. 예를 들어 CPU,메모리 리스크가 큰 요구사항은 성긴 그물로 강의 상류에서 잡고, 작은 것은 촘촘한 그물로 강 하류에서 바다로 나가기 직전에 잡는다.*



스토리 수집 기법으로 사용자 인터뷰, 설문, 관찰, 스토리 작성 워크숍이 있다.

- 사용자 인터뷰
  - 개방형 질문(Open ended)과 문맥 무관 질문(context free) : 사용자의 넓고 다양한 의견을 수집
    - 다양한 방향으로 의견을 개진할 수 있게 "yes" or "no"로 답변하는 질문은 피하라
    - 질문에는 암시적으로 질문자 선호도가 나타나지 않아야 한다.
      - 얼마나 빨리 검색되어야 하는가? 보다는 어떤 형태의 성능이 필요합니까? 로...
    - 처음에는 cocntext free질문으로 시작하여, 구체적인 질문으로 확대하라..
- 설문
  - 이미 만들어진 스토리에서 다수의 사용자로 부터 우선순위나 선호도를 알기 위해 적합하다.
  - 설문은 한 방향으로 전달되고, 질문과 응답의 시간 간격이 길어서 스토리 수집에 적합하지 않다. 
- 관찰
  - 사용자가 소프트웨어를 사용하는 것을 관찰
- 스토리 작성 워크샵
  - 가능한 짧은 시간에 최대한 많은 사용자 스토리를 작성한다.
  - 브레인스토밍과 충실도 낮은 프로토타입(low-fidelity prototype) 장점을 모은것
  - 충실도 낮은 프로토타입은 개념적은 작업 흐름을 한다.
    - 먼저, 사용자 역할로 시작할지 결정해야 한다.
    - 화면 구성 등 구체적인 것은 제외하고 작업 흐름을 따라가면서 많은 생각을 끌어낸다.
    - 깊이 우선(depth-first)가 너비 우선 보다 효율적이다.
  - 질보다 양에 촛점을 맞춘다

*시사점:  사용자 역할을 모델링하여 대상자들로 부터 인터뷰하여 '무언가'를 뽑고, 그 '무언가'의 우선순위를 알기 위해서 설문을 활용해보자*

*시사점:  사용자를  만나서 직접 관찰할 수 없다면,텔레메트리를 통해서 간접적으로 관찰한다. A/B 테스트*

*시사점: "사용자 역할 별"로 "개념적인 작업 흐름" 을 깊이 우선으로 탐색해 본다는 기법은 다양한 분야에서 낮은 충실도의 프로토타입시에 활용가능할 듯 하다.*



# 5. 대리 사용자와 일하기 (Working with User Proxies)

사용자의 관리자 (The Users' Manager)



개발팀 관리자

- 신기술 시도, 프로젝트 종료 일정에 우선순위. 또한 전문가가 아님.

영업 사원

- 그들의 마지막 거래에서 문제가 된 특정 기능에만 주의를 기울임. 

해당 분야 전문가

- 도메인 모델과 비지니스 규칙에 적합, 작업 흐름이나 사용방법에는 부적합
- 전문가 정도의 지식 수준에 맞춤

마케팅 그룹

- 사용자 보다는 시장을 더 잘 이해하려는 경향
- 각 기능의 품질보다는 제품의 기능 목록에 치우치게 됨

이전 사용자

- 현재와 사용 목적이나 동기가 일치하는지 검토 필요

고객

- 구매 결정을 내리는 사람이지, 반드시 사용자로 볼 수 없다.

교육 담당 및 기술 지원

- 실제 사용자와 많은 시간을 보내어 적합. 하지만, 교육과 기술지원하기 쉬운데 촛점

비즈니스 분석가 또는 시스템 분석가

- 기술 영역과 도입하려는 분야 양쪽에 몸담아서 적합. 하지만, 연구 보다는 공상. 초기에 분석을 위한 선행 작업 시간이 너무 길다.

*시사점: 상품 기획은 시장을 이해해서 기능 목록에 집중. 그렇다면 각 기능의 품질(사용성)은?? UX가 담당*

*시사점: 시스템의 요구사항을 가장 잘 표현할 수 있는 것은 유스케이스 모델이 아니라 사용자 메뉴얼일 수 있다.*



# 6. 사용자 스토리 인수테스트

*시사점: 사용자 스토리는 전통적인 방식으로 세부적인 요구 사항을 명세하기 보다 테스트로 대신한다. 또한, 구현 전에 테스트를 우선 작성한다. 우리의 경우에도 SRS와 TC를 둘 다 유지하는 것은 낭비가 아닌가? 게다가 최근에는 앱의 단위테스트 요구사항도 기술하고 있다. 낭비제거가 필요해 보인다*

*시사점 : 사용자 스토리는 테스트를 고객이 작성해야 한다고한다. 모든 세부적인 사항은 아닐지라도...이것은 고객의 의도를 정확하게 개발자에게 전달하기 위한 것이다. 우리도 테스트 작성시(혹은 SRS) RM과 UX가 리뷰 하는가? -> UX담당자가 실물로 사용은 해보는가?*

# 7장. 좋은 스토리를 위한 지침

목적 스토리로 시작해라 (Start with Goal Stories)

- 한번의 하나씩 사용자 역할을 선택해서, 그 사용자가 새 시스템을 사용하는 주 목적을 식별

케이크 자르듯 나누어라(Slice the Cake)

- 기술적인 측면에서 나누지 말고, 기능 단위로 나누어라
- 아키텍처의 모든 계층을 포함해서, 마지막 순간에 특정 계층에서 문제가 발견되는 리스크를 줄인다.
- 기능이 일부만 구현되어도 사용자에게 릴리즈할 수 있는 상태가 된다.

닫힌 스토리를 작성하라(Write Closed Stroies)

- 의미 있는 목적을 달성하는 형태로 작성되어, 사용자로 하여금 무언가를 해냈다고 느끼게 하는 것

제약 사항 (Put Constraints on Cards)

- 제약 사항을 카드에 넣어라
- 작업량에 넣거나 직접 구현할 내용은 아니지만, 시스템이 반드시 시켜야 할 것

스토리 크기는 시간에 맞추어라(Size the Story to the Horizon)

- 앞서 진행해야 하는 것은 작은 스토리로, 늦게 진행되는 것은 큰 스토리로...

되도록 사용자 인터페이스를 배제하라(Keep the UI Out as Long as Possible)

- 초기에는 사용자 이터페이스에 관한 세부사항을 스토리에 포함하지 말라

스토리에 사용자 역할을 포함하라(Include User Roles in the Stories)

- 나는(역할)로서 (비지니스 가치)를 위해 (기능)을 원한다.

한 명의 사용자를 대상으로 작성하라(Write for One User)

- 구직자는 이력서를 작성할 수 있다.(X), 구직자는 자신의 이력서를 작성할 수 있다.(O)

능동태로 작성하라(Write in Active Voice)

고객이 작성하라(Customer Writes)

스토리 카드에 번호를 부여하지 말라

- 불필요한 비용과 불필요한 추상성을 개입. 차라리 짧은 제목, 키워드를 사용하라

목적을 잊지마라

- 스토리 카드의 주 목적은 구현할 기능을 논의하기 위한 단서 역할. 간결해야 한다. 
- 너무 많은 세부사항을 넣어서, 카드가 대화를 대신하게 하지 말라.

*시사점 : 제약 사항과 기능요구사항이 애매할때 구현할 내용인지, 지켜야할 내용인지로 구분해 보자.*

*시사점 : 초기에는 큰 그물망으로 정밀도가 낮은 개략적인 큰 단위의 스토리로 펼치고, 시간축으로 단계적으로 촘촘한 그물로 구체적인 것을 작성한다.*

*시사점 : (인식된 사용자)는 (목적)을 위해 (기능)을 (실행 완료)한다. 는 형식은 매우 유효해 보인다.*

*시사점: 우리의 애널리틱스는 기능의 사용횟수에 촛점이 맞추어지고, 기능의 품질(사용성)은 없으므로 추가할 필요가 있다. 즉, UX품질도 측정 해야 한다. 예를 들어 이전에는 사용자가 네트워크 메뉴 진입에서 완료까지 30초걸렸는데, 신규 네트워크 메뉴에서는 60초가 걸렸다면, 사용성 품질이 더 낮아 진 것이다.*