# 1장 마이크로서비스

## 마이크로 서비스란

마이크로 서비스란 작고 자율적으로 협업하는 서비스이다.  그 특징에 대해 살펴 본다.

#### 작고 한가지 일을 잘하는데 주력(Small, and Focused on Doing One Thing Well)

같은 이유로 변경되는 것은 한데 모으고, 서로 다른 이유로 변경되는것은 분리한다. 이를 통해 서비스 경계를 비즈니스 경계에 일치 시킨다.

얼마나 작아야하는가? 

- 2주안에 코드를 재작성가능하다.
- 코드 크기가 하나의 팀이 감당하기에 적합해야 한다.

#### 자율성 (Autonomous)

서비스간 결합을 느슨하게 하기 위해 모든 통신은 네트워크 호출을 통해 이루어 진다.

다른 변경 없이 특정 서비스만 변경하고 독립적으로 배포할 수 있다. 

이것을 위해 기술 중립적인(technology-agnostic) API를 제대로 만들어야 한다.

------------------------------------------------------------------------------------------------------------

## 주요 혜택

#### 기술 이기종성 (Technology Heterogeneity)

각 서비스가 다른 기술을 사용하도록 결정 할 수 있다.  새로운 기술을 더 신속하게 적용할 수 있다.

- 최소한의 공통점만 가진 표준화된, one-size-fits-all apporach 를 선택하기 보다는, 각 작업에 적합한 도구를 선택하게 해준다.

반면에 모놀리식 서비스는 새로운 기술을 시도하면 시스템 전체에 큰 영향을 줄 수 있다.

#### 회복성 (Resilience)

컴포넌트에 장애가 발생하더라도, 장애가 전파되지 않게 격리하여 나머지 시스템을 계속 작동시킬 수 있다.

반면에 모놀리식 서비스는 한 부분만 고장나면 시스템 전체가 동작을 멈춘다.

#### 확장성 (Scaling)

필요한 서비스 단위로 확장(scale)할 수 있고, 나머지 서비스를 늦은 하드웨어에서 실행 할 수도 있다.

- AWS는 주문형 확장 시스템(on demand provisioning system)을 도입

반면에 모놀리식 서비스는 시스템의 한 부분만 성능이 떨어져도 전체를 함께 확장해야 한다

#### 배포 용이성 (Ease of Deployment)

하나의 서비스만 변경가능하고, 나머지 시스템과 독립적으로 배포 할 수 있다. 더 신속하게 배포할 수 있고 문제가 발생해도 쉽게 대응할 수 있다. (해당 서비스만 rollback할수도 있다.)

반면에 모놀리식 서비스는 한 줄만 수정해도 전체를 배포해야 한다. 수차례의 릴리스가 축적된 수 많은 변경 사항이 한꺼번에 배포된다. 느린 배포와 문제 위험성이 높아 진다.

#### 조직 부합성 (Organizational Alignment)

아키텍처를조직 구조에 맞게 더 적절히 정렬할 수 있다. 더 작은 팀이 더 작은 코드베이스로 정렬하여 생산성을 높일 수 있다.  분산된 팀과 협업하기도 용이하다.

#### 조합성 (Composability)

서비스 단위로 외부에서 접근가능해서(재사용이 가능해서) 다양한 환경과 목적에서 다른 방식으로 구축할 수 있다.

반면에 모놀리식 서비스에서 각 부분을 외부에서 접근하게하려면 전체 시스템을 다 때려 부쉬야 할 것이다.

#### 대체용이성 (Optimizing for Replaceability)

서비스 단위로 쉽게 대체하거나 삭제할 수 있다.

반면에 모놀리식 서비스는 지저분한 레거시 부분이 있어도 교체하기 어렵다.

-----------------------------------------------------------------

## 서비스 지향 아키텍처 (Service-Oriented Architecture)

SOA는 여러 서비스를 프로세스 단위로 분리하고 서비스간 통신을 네트워크 호출로 이루어진다. 이를 통해 소프트웨어 재사용성을 높이고, 서비스 단위의 교체를 쉽게하여 유지보수성을 높인다.

하지만 구체적인 지침이 없었으며, 마이크로 서비스는 이를 보완하는 SOA에 대한 특정 접근법으로 볼 수 있다.

-------------------------------------------

## 기타 분해 기술 (Other Decompositional Technique)

#### 공유 라이브러리

팀과 서비스간에 기능을 공유하여 재사용성을 높인다. 하지만, 아래와 같은 단점이 있다.

1. 기술 이기종성을 잃어 버리게 된다. (언어나 플랫폼에 종송적이다.)
2. 시스템 일부를 독립적으로 확장(scale)하기 어렵다.
3. 변경 부분만 격리해서 재배포하기 어렵다. (전체 프로세스가 재배포 될 수 있다.)
4. 시스템 회복력을 고려하기 어렵다. (오히려, 결함이 발생하는 접점이 되기도 한다.)

#### 모듈

일부 언어는 "공유 라이브러리" 보다 더 뛰어난 독자적인 모듈 분해 기술을 제공한다. 하지만, 공유라이브러리의 취약점을 그대로 가지고 있으며, 모률 간에 강하게 결합되면 장점을 잃어 버린다. 

마이크로 서비스는 프로세스 간의 경계를 통해 자연스럽게 느슨하게 결합되도록 유도한다.

-------------------------------------------

## 은총알은 없다 (No Silver Bullet)

마이크로 서비스도 공짜가 아니다. 잘못 사용될 경우 분산 시스템과 연관된 모든 종류의 복잡성을 내포하고 있다.  

------------------------------------------



# 2장 진화적 아키텍트 (The Evolutionary Architect)

## 아키텍트의 대한 진화적 관점 (An Evolutionary Vision for the Architect)

소프트웨어 아키텍트는 '건축가' 라기 보다는 '도시 설계자(city planner)' 에 가깝다. 

건축과 다르게 소프트웨어는 초기 릴리즈 이후에도 계속 변화한다. 그러므로 아키텍트는 처음부터 완벽한 것 보다는 지속적으로 성장할 수 있는 시스템을 만들어야 한다.

사용자 뿐만 아니라 개발자, 테스터도 수용가능한 시스템을 만들어야 한다. 

방향 자체는 개괄적으로 설정하고 최소한 관여하더라도, 특정 경우에(제약 위반, 비용 리스크 등) 세부 구현에 매우 구체적으로 간여해야 한다.

---------------------------

## 구역화 (Zoning)

구역 내부를 걱정하는 사람은 많다. 구역 내부의 일은 최대한 자유로워야 하며(팀을 신뢰), 아키텍트는 구역 사이에서 발생하는 일들에 고민하고 모니터링해야 한다.

------------------------------------------

## 원칙적인 접근법(A Principled Approach)

시스템 설계 상의 의사 결정은 트레이드오프(trade-off)에 대한 선택이다.  결정에 도움을 주기 위해 설계 원칙과 실천 사항을 정의할 필요가 있다. 즉, 의사 결정을 프레이밍(framing) 한다.

#### 전략적 목표 (Strategic Goals)

조직이 지향하는 비지니스 관점의 전략적 목표를 수립한다.

- 예를 들어 플랫폼 외판 사업 확대, 플랫폼 업그레이드 운영, 지역적으로 분리된 조직 활용 등이다.

#### 원칙 (Principles)

원칙은 전략적 목표를 위해 할 일을 정렬하는 규칙이다.

- 예를 들어 플랫폼 외판 사업 확대라는 전략적 목표를 위해 "플러그인 구조 늘리기" 원칙을 세운다.
- 예를 들어 지역적으로 분리된 조직 활용이라는 전략적 목표를 위해 "분리된 모듈의 개발 독립성 확보" 원칙을세운다.

원칙의 수는 10개 미만인 것이 좋다. 사람이 외우기 쉽고, 벽에 붙인다면 한눈에 파악할 수 있다. 원칙이 많아지면 모순되거나 서로 겹친다.

원칙은 변경 가능한 것과 변경 될 수 없는 제약 사항이 있을 수 있다.

#### 실천 사항 (Practices)

실천 사항은 원칙을 실행하는 방법으로, 업무 수행을 위한 자세하고 실질적인 지침이다.

이것은 대개 기술 명세서이며, 모든 개발자가 이해할 수 있도록 충분히 구체적이어야 한다. 또한, 원칙보다는 변경 가능성이 높다.

- 예를 들어 플러그인 구조 늘리기 원칙을 위해, "가변 정책에 대한 테이블 주도 디자인(table driven design)적용" 실천 사항을 규정한다.
- 예를 들어 분리된 모듈의 개발 독립성 확보 원칙을 위해, "분리된 모듈의 순환 의존성(cycle dependency) 제거" 실천 사항을 규정한다.

#### 원칙과 실천 사항의 결합 (Combining Principles and Practices)

소규모 조직에서는 원칙과 실천 사항이 같을 수 있다. 하지만, 대규모 조직에서는 공통된 원칙을 지향하면서도 기술적 실천 사항이 팀마다 다를 수 있으므로 원칙과 실천 사항을 나눈다.

#### 실전 사례 (A Real-World Example)

몇몇 항목은 문서화한다. 그리고 구체적인 코드 사례와 도구를 만드는 것이 좋다.

![image-20200523232525626](../images\mircroarchitecture\F2.1.png)

--------------------------

