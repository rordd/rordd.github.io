# 클린 아키텍쳐 요약
## 1장. 설계와 아키텍쳐란?

**아키텍쳐(architecture)와 설계(design)의 차이는?**

일반적으로 상위 수준의 결정사항을 아키텍처, 그리고 저수준의 세부사항에 대한 결정사항을 설계라고 부르는 경향이 있다.
하지만, 그 경계는 뚜렷하지 않고 고수준에서 저수준으로 향하는 의사 결정의 연속성만 있을 뿐이다.

**SW아키텍쳐의 목표는?**

시스템을 만들고 유지보수하기 위한 비용을 최소화하는 것이다. 
즉, 좋은 설계란 고객의 요구 사항을 만족시키는데 드는 비용을 지속적으로 낮게 유지할 수 있고, 반대로 나쁜 설계란 비용을 지속적으로 증가 시킨다.

>*시사점 : 설계 문서 상에서는 HLD를 아키텍쳐, 그리고 LLD를 디자인(설계)로 경계를 둔다. 
이로 인해서 아키텍트는 HLD와 같은 상위 수준만을 중요하게 다룰 것이란 오해를 가질 수 있다.*

>*하지만, 실제로 현장에서 아키텍트가 중요하게 다루어야 할 것은 고수준 혹은 저수준에 상관없이 비용에 크게 영향을 주는 결정 사항이어야 한다.*

>*이것으로 부터 Architectually Significant Requirement의 진정한 의미는
그 추상화 수준과 상관없이 "구현, 테스트, 유지보수" 비용을 높일 가능성이 있는 요구 사항으로도 정의할 수 있다*

>*이러한 관점은 Non Local Change의 분류 기준에도 포함 되어야 한다.*

**유지보수 비용 산출**

몇 가지 그래프를 통해서 비용 증가 추이로 부터 설계 품질을 관접적으로 평가 할 수 있다. 

* 엔지니어링 직원 수 (X=제품 출시 시점, Y=직원수(비용)) 

* 코드 라인수 (X=제품 출시 시점, Y=코드 라인수)
  
* 코드 라인당 비용 (X=제품 출시 시점, Y=코드 라인당 비용)
  * 나쁜 설계로 인해서 해가 갈수록 생산성이 감소되고 비용은 증가한다.
  
**개발자의 잘못된 과신**
1. 바쁘니까 코드는 나중에 정리하고, 당장은 시장에 출시하는 것이 먼저다.
  *이전에 작성한 코드를 정리하는 일은 일어나지 않는다. 다음 기능, 또 다음 기능이 계속 기다리고 있기 때문이다.

2. 지저분하게 코드를 작성하면 단기간에는 빠르게 갈수 있고, 장기적으로만 생산성이 낮아 진다.
  *아니다. 단기적으로도 제대로 짠 코드가 더 빠르다.
  
3. 망가진 시스템을 버리고 처음부터 다시 시작하여 전체 시스템을 재설계하는 것이 해답이다.
  *아니다. 위와 같은 과신을 가진다면 재설계를 하더라도 원래의 프로젝트와 똑같이 엉망으로 만들 것이다.
 
 결국 빨리가는 유일한 방법은 처음부터 제대로 가는 것이다.
 
 >*시사점 : 우리 조직에서도 유지보수 비용 혹은 개발자 생산성을 산출해 볼 수 있다.*
 
 >*사례 : 코드 라인수와 비용(문제점 발생 수, 직원 수)*
 
 **결론**
 * 조직에 스며든 과신을 인지하여 방지하고 소프트웨어 아키테처 품질을 심각하게 고민할 필요가 있다.
 * 좋은 소프트웨어 아키텍처란 개발 및 유지보수의 비용을 최소화하고 생산성을 최대화 하는 것이다. 

----------

## 1장. 두 가지 가치에 대한 이야기
**기능 요구 사항이 중요한가? 아키텍쳐가 중요한가?**
소프트웨어 시스템을 동작하게 만드는 것이 중요한가? 아니면 소프트웨어 시스템을 더 쉽게 변경할 수 있도록 하는 것이 중요한가?
* 완벽하게 동작하지만, 변경이 불가능하다면 --> 요구 사항이 변경 될때 동작하지 않게 되어 쓸모가 없는 시스템이다.
* 동작은 하지 않지만, 변경이 쉽다면 --> 동작하도록 쉽게 만들 수 있다. 

변경이 불가능하다는 것은 변경 비용이 창출되는 수익보다 높은 경우를 말한다.

**아이젠하워 매트릭스**
중요성과 긴급성의 메트릭스로 업무를 우선 순위화 할 수 있다. 

* 기능 요구 사항
  * 긴급하고 중요하다.
  * 긴급하고 중요하지 않다.
* 아키텍쳐
  * 긴급하지 않지만 중요하다.
  
흔한 실수는 긴급하고 중요하지 않은 기능요구사항을 중요하다고 착각해서, 이로 인해 아키텍쳐 중요도가 떨어지는 것이다.

**아키텍처를 위한 투쟁**
아키텍트는 *뻔뻔함을 무릅쓰고*, 다른 이해관계자들(마케팅, 영업 등)과 싸워서 아키텍처를 보호해야 한다. 개발하기 쉽고, 변경하기 쉬운 확장성 있는 아키텍처를 만들어야 한다.

>*시사점 : 많은 사람들이 긴급한 것을 중요한 것으로 착각한다. 
그래서, 긴급하지만 중요하지 않은 요구사항으로 인해 더 중요한 아키텍처가 망가지곤 한다. (기술적 부채가 쌓인다.)*

>*기술적 부채는 단건으로 보면 사소해 보이지만 방만한 관리로 축적된다면, 미래에는 사소한 변경에도 큰 비용을 발생시키는 경직된 아키텍처를 초래한다*

>*아키텍트는 이 논리로 기술적 부채를 중요하지 않은 요구 사항보다 우위에 두도록 여러 이해 관계자들을 설득시켜야 한다.*




