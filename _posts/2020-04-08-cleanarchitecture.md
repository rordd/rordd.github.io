# 1부 소개
## 1장. 설계와 아키텍쳐란?

**아키텍쳐(architecture)와 설계(design)의 차이는?**

일반적으로 상위 수준의 결정사항을 아키텍처, 그리고 저수준의 세부사항에 대한 결정사항을 설계(디자인)라고 부르는 경향이 있다.
하지만, 그 경계는 뚜렷하지 않고 고수준에서 저수준으로 향하는 의사 결정의 연속성만 있을 뿐이다.

**SW아키텍쳐의 목표는?**

시스템을 만들고 유지보수하기 위한 비용을 최소화하는 것이다. 
즉, 좋은 설계란 고객의 요구 사항을 만족시키는데 드는 비용을 지속적으로 낮게 유지할 수 있고, 반대로 나쁜 설계란 비용을 지속적으로 증가 시킨다.

>*시사점 : 설계 문서 상에서는 HLD를 아키텍쳐, 그리고 LLD를 디자인(설계)로 경계를 둔다. 
이로 인해서 아키텍트는 HLD와 같은 상위 수준만을 중요하게 다룰 것이란 오해를 가질 수 있다.*

>*하지만, 실제 현장에서 아키텍트가 중요하게 다루어야 할 것은 현재와 미래의 개발 비용에 크게 영향을 주는 결정 사항이어야 한다.*

>*이것으로 부터 Architectually Significant Requirement의 진정한 의미는
그 추상화 수준과 상관없이 "구현, 테스트, 유지보수" 비용을 높일 가능성이 있는 모든 종류의 요구 사항으로도 정의할 수 있다*

>*이러한 관점은 아키텍쳐 요구사항을 선정할때 Non Local Change와 함께 분류 기준으로 추가 될 필요가 있다.*

**유지보수 비용 산출**

몇 가지 그래프를 통해서 비용 증가 추이로 부터 설계 품질을 간접적으로 평가 할 수 있다. 

* 엔지니어링 직원 수 (X=제품 출시 시점, Y=직원수(비용)) 

* 코드 라인수 (X=제품 출시 시점, Y=코드 라인수)
  
* 코드 라인당 비용 (X=제품 출시 시점, Y=코드 라인당 비용)
  * 나쁜 설계로 인해서 해가 갈수록 생산성이 감소되고 비용은 증가한다.
  
**개발자의 잘못된 과신**

* 바쁘니까 코드는 나중에 정리하고, 당장은 시장에 출시하는 것이 먼저다.
  * 그러나, 이전에 작성한 코드를 정리하는 일은 일어나지 않는다. 다음 기능, 또 다음 기능이 계속 기다리고 있기 때문이다.
* 지저분하게 코드를 작성하면 단기간에는 빠르게 갈수 있고, 장기적으로만 생산성이 낮아 진다.
  * 아니다. 단기적으로도 제대로 짠 코드가 더 빠르다. 이것은 시점에 상관없이 항상 그렇다.
* 망가진 시스템을 버리고 처음부터 다시 시작하여 전체 시스템을 재설계하면 좋아 질 것이다.
  * 아니다. 위와 같은 과신을 가진다면 재설계를 하더라도 원래의 프로젝트와 똑같이 엉망으로 만들 것이다.
 
 결국 빨리가는 유일한 방법은 처음부터 제대로 가는 것이다.
 
 >*시사점 : 우리 조직에서도 유지보수 비용 혹은 개발자 생산성을 산출해 볼 수 있다.*
 
 >*사례 : 코드 라인수와 비용(문제점 발생 수, 직원 수)*
 
 **결론**
 
 * 조직에 스며든 과신을 인지하여 방지하고 소프트웨어 아키테처 품질을 심각하게 고민할 필요가 있다.
 * 좋은 소프트웨어 아키텍처란 개발 및 유지보수의 비용을 최소화하고 생산성을 최대화 하는 것이다. 

>*시사점 : 아키텍쳐란 결국 개발, 테스트, 유지보수 비용을 최소화해서 개발 생산성을 극대화하기 위한 것이다.
즉, 아키텍쳐의 목적은 수율을 높이는 것이다*

---

## 2장. 두 가지 가치에 대한 이야기

**동작하는 소프트웨어가 중요한가? 아키텍쳐가 중요한가?**

소프트웨어 시스템을 동작하게 만드는 것이 중요한가? 아니면 소프트웨어 시스템을 더 쉽게 변경할 수 있도록 하는 것이 중요한가?
* 완벽하게 동작하지만, 변경이 불가능하다면 --> 요구 사항이 변경 될때 동작하지 않게 되어 쓸모가 없는 시스템이다.
* 동작은 하지 않지만, 변경이 쉽다면 --> 동작하도록 쉽게 만들 수 있다. 

변경이 불가능하다는 것은 변경 비용이 창출되는 수익보다 높은 경우를 말한다.

**아이젠하워 매트릭스**

중요성과 긴급성의 메트릭스로 업무를 우선 순위화 할 수 있다. 

* 기능 요구 사항
  * 긴급하고 중요하다.
  * 긴급하고 중요하지 않다.
* 아키텍쳐
  * 긴급하지 않지만 중요하다.
  
흔한 실수는 긴급하고 중요하지 않은 기능요구사항을 중요하다고 착각해서, 이로 인해 아키텍쳐 중요도가 떨어지는 것이다.

**아키텍처를 위한 투쟁**

아키텍트는 *뻔뻔함을 무릅쓰고*, 다른 이해관계자들(마케팅, 영업 등)과 싸워서 아키텍처를 보호해야 한다. 이를 통해 개발하기 쉽고, 변경하기 쉬운 확장성 있는 아키텍처를 만들어야 한다.

>*시사점 : 많은 사람들이 긴급한 것을 중요한 것으로 착각한다. 
그래서, 긴급하지만 중요하지 않은 요구사항으로 인해 더 중요한 아키텍처가 망가지곤 한다. (기술적 부채가 쌓인다.)*

>*기술적 부채는 단건으로 보면 사소해 보이지만 방만한 관리로 축적된다면, 미래에는 사소한 변경에도 큰 비용을 발생시키는 경직된 아키텍처를 초래한다. 변경에 유연한 아키텍처로 되돌리는 비용은 너무나 크기 때문에 기술적 부채의 악순환은 반복된다.*

>*아키텍트는 이러한 논리로 기술적 부채를 중요하지 않은 요구 사항보다 우위에 두도록 여러 이해 관계자들을 설득시켜야 한다.*

---------------------------------------------------------------------------------------------------------------------


# 3부 설계 원칙

SOLID 원칙은 함수와 데이터 구조를 클래스에 배치하고, 클래스들을 서로 결합하는 방법을 설명해준다. (OO의 클래스만을 지칭하는 것은 아니다.)
SOLID는 중간 수준의 소프트웨어, 즉 소스코드보다는 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 SW구조를 정의하는데 도움을 준다.

* SRP 단일 책임 원칙 Single Responsibility Principle : 소프트웨어 모듈은 변경의 이유는 단 하나여야만 한다. 
* OCP 개방-폐쇄 원칙 Open-Closed Principle : 기존 코드가 수정되기 보다는 반드시 새로운 코드를 추가하는 방식으로 설계되어 변경용이성이 높다.
* LSP 리스코프 치환 원칙 Liskov Substitution Principle : 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 준수해야 한다.
* ISP 인터페이스 분리 원칙 Interface Segregation Principle : 소프트웨어 설계자는 사용하지 않는 것에 의존하지 않아야 한다는 원칙이다.

## 7장. SRP 단일 책임 원칙

SRP란 이름으로 인해 모든 모듈들이 단 하나의 일만해야 한다는 의미로 오해 할 수 있다. 그것은 함수 수준의 원칙이며 모듈 수준에 적합한 SRP 원칙에 대한 설명은 아래와 같다.

* 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다
* 하나의 모듈은 하나의, 오직 하나의 액터(집단)에 대해서만 책임져야 한다.

모듈이란 소스 파일이며, 혹은 함수와 데이터 구조로 구성된 응집된 집합니다. '응집된(cohesive)'는 SRP를 암시하며, 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 '응집력(cohesion)'이다.

이 원칙을 이해하기 위해 이 원칙을 위반하는 징후들을 살펴 보자

**징후 1. 우연한 중복**

단일 모듈이 여러 액터에 대해 책임질 경우 그들간의 코드 중복을 피하기 위해 공용 메서드를 만들게 되곤한다. 하지만 이것은 우연한 중복일 수 있다. 사실은 미래에는 변경되는 이유가 서로 달라서 한 액터의 요구로 변경된 공통 메서드가 다른 액터에게는 의도하지 않은 악영향을 줄 수 있다.

즉, 우연히 중복 된 것일 뿐 서로 다른 액터에게 의존하는 코드여서 미래에는 서로 다른 이유로 상이하게 변경될 수 있다.

이것은 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문이다. SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.

>*시사점 : 일반적으로 코드 중복은 무조건 나쁜것으로 생각된다. 하지만, 이것은 우연한 중복일 수 있다. 즉, 미래에 서로 다른 이유로 변경될 가능성이 있는 중복 코드라면 공용화하지 말고 중복을 허용하는 것이 맞을 수 있다.*

**징후 2. 병합**

소스 파일에 다양하고 많은 메서드를 포함하고 특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 높다. 특히 다른 책임 별로 다른 개발자나 조직이 담당한다면 잦은 병합과 상호 변경 영향으로 인한 위험을 유발한다. 

즉, 많은 사람이 서로 다른 이유로 동일한 소스 파일을 변경하는 경우에 해당되며, 이 문제를 벗어나는 방법은 서로 다른 액터에 의존적인 코드를 서로 분리하는 것이다.

>*시사점 : 단일 git에서 서로 다른 개발자가 수정을 한다면 SRP를 위반했을 가능성이 높다. git을 분리하거나, 최소한 개발자 별로 변경하는 파일을 분리해야 한다.*

**해결책**

이러한 문제점의 해결 책은 서로 다른 액터를 책임지는 코드를 서로 다른 클래스(파일)로 분리하고, 필요하다면 그들간에 간단한 데이터 구조 클래스(파일)을 만들어서 공유하는 것이다. 

이 경우에 다수의 클래스를 인스턴스화하고 추적해야 하는 단점이 있는데, 이를 위한 퍼사드 패턴이 있다.

퍼사드 패턴이란 다수의 클래스의 객체를 생성하고 요청된 메서드를 가지는 객체로 위임하는일을 책임지는 클래스를 만드는 것이다.

>*시사점 : 수많은 메소드를 가진 거대한 클래스가 있다면 메소드들을 응집력 있게 묶어서 다수의 클래스로 분리하여 작은 클래스로 변경하고,분리된 클래스들을 포함한 후에 위임하도록 변경해야한다.*

>*시사점 : 우연한 중복의 오류를 유발할 가능성이 높은 상속 관계를 지양하고, 포함 관계를 활용하자*

**결론**

SRP는 클래스(파일)수준의 원칙이다.하지만 상위 수준에서도 다른 형태로 등장한다. 컴포넌트 수준에서는 공통 폐쇄원칙, 아키텍처 수준에서는 아키텍처 경계(Architecture Boundary)의 생성을 책임지는 변경의 축이다.

## 8장. OCP 개방 폐쇄 원칙

일반적인 정의는 아래와 같다. 

* 소프트웨어 개체는 확장에는 열려 있어야하고, 변경에는 닫혀 있어야 한다는 것이다.  (즉, 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.)
* 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 것이다.

실전적인 방법은 아래와 같다.

* A 컴포넌트에서 발생하는 변경으로 부터 B컴포넌트를 보호하려면 반드시 A컴포넌트가 B컴포넌트에 의존해야 한다. (A-->B)
* 책임에 맞게 컴포넌트 단위로 분리하고(SRP), 저수준 컴포넌트에서 발생한 변경으로 부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계측 구조가 만들어져야 한다. (저수준 --> 고수준)

OO기반에서는 의존성을 통제하기 위한 기법은 아래와 같다.

* 방향성 제어는 인터페이스를 이용해 의존성을 역전 시킨다.
* 컴포넌트 내부 요소와의 추이 종속성(transitive dependency)을 제거하기 위해 인터페이스를 이용하여 정보를 은닉한다.

>*시사점 : 고수준은 개념 보다는 저수준 개념이 확장 가능성이 높다는 전재가 필요하다. 일반적으로 상위 수준 정책(Usecase)과 세부사항이라는 기준으로 나누지만, 무엇이 고수준이고 저수준인지를 가르는 잦대 중 하나는 확장 가능성의 정도가 될 것이다.*

>*시사점 : 추이 종속성, 즉 A가 B에 의존하고 B가 C에 의존하면 A는 C에 의존한다는 용어는 외워 두면 커뮤니케이션 시에 좋을 듯 하다.*

## 9장. LSP 개방 폐쇄 원칙

단순히 상속을 사용하는 가이드가 아니라 소프트웨어 설계 원칙이다. 

상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들려면, 이들 구성요소는 반드시 서로 치환 가능하도록 시스템을 유지해야 한다는 의미이다.

예를 들어 REST API를 이용해서 여러 URI 중 하나로 데이타를 전송하는 코드에서, 특정 URI의 데이타 스케마가 달라져야 하는 예외적인 처리를 한다고 가정하자.

소스 코드에서 if else로 분기해서 다른 URI들과 서로 치환 가능하지 않게 하기 보다는, URI를 키로 하는 DB를 구성하고 DB에서 스케마를 분리한다. 그리고, 소스코드는 분기 없이 DB의 내용에 따라 데이타를 구성한다. 이렇게 하면 URI들간에 여전히 치환 가능한 소스 코드를 유지 할 수 있다.

>*시사점 : 웹 오에스에서 상호 대체 가능한 구성요소를 이용한 시스템은 무엇인가? 광의적으로 해성하면 여러 클라이어트에게 API를 제공하는 모든 종류의 서비스와 앱이다. 그렇다면 치환 가능하지 않게 만든 흔적은 무엇인가? 특정 서비스, 앱에서 특정 uri로 분기를 친 소스코드들이다. 이런 코드를 찾아서 분기요소를 제거할 필요가 있다. 분기 제거 방법으로 분기 요소를 저장한 DB가 효율적일 것이다*

## 10장. ISP 인터페이스 분리 원칙
하나의 클래스가 여러 메소드를 제공할 경우 그중 하나만 변경이 되어도 클래스를 참조하는 다른 사용자 전부를 컴파일하고 재배포해야한다. 이것은, 메소드 별로 인터페이스를 만들어 사용자와 클래스의 정적 의존성을 디커플링하는 방법 등으로 해결할 수 있다.

이것은 소스코드에 포함된 선언문으로 소스코드 의존성이 발생하는 정적 타입의 언어에 의존한다. 

동적 타입의 언어에서는 발생하지 않으며, 상대적으로 결합도가 낮은 시스템을 구성할 수 있는 이유이다.

아키텍처 관점의 시사점은 불필요한 의존성을 피할 수 있게 설계하라는 의미이다. 이것은 SRP와 대치될 수 있는 개념 일 수 있다. 

악영향에 대해 예를 들어 보면, S -> F -> D 관계에서 S와F와 무관한 D의 변경점으로 인해서 S와 F를 재배포해야 할 수도 있다.  

---------------------------------------------------------------------------------------------------------------------

## 11장. DIP 의존성 역전 원칙

# 4부 컴포넌트 원칙
## 12장 컴포넌트

컴포넌트는 독립적으로 개발 및 배포 가능한 최소 단위이다. (다른 용어로 패키지이다.)
런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일을 말한다.

* 컴파일형 언어에서는 바이너리의 결합체
* 인터프리터형 언어에서는 소스코드의 결합체

13장은 컴포넌트 응집도와 관련된 세 가지 원칙으로 클래스나 모듈을 패키지에 할당하는 일을 도와준다.
14장은 컴포넌트 결합에 대한 세가지 원칙으로 컴포넌트간의 관계를 결정하는 일을 도와준다.

## 13장 컴포넌트 응집도

REP:재사용/릴리즈 등가 원칙 Reuse/Release Equivalence Principle : 재사용되려면 릴리즈 수준의 관리가 필요하다.
OCP:공통 폐쇄 원칙 Common Closed Principle : 동일 이유로 변경되는 코드가 여러 컴포넌트로 흩어지면 안된다는 말이다. 같은 컴포넌트로 폐쇄되어야 한다.
CRP:공통 재사용 원칙 (Common Reuse Principle) : 강하게 결합되어 있지 않은 모듈들은 동일 컴포넌트로 묶지 말라는 말이다. 그래서 해당 컴포넌트를 참조하는 다른 컴포넌트들에 불필요한 영향을 주지 말라는 말이다.

**REP : 재사용/릴리즈 등가 원칙**

재사용 단위는 릴리즈 단위와 같다. 즉, 재사용하려면 릴리즈 수준의 관리를 해야 한다.(릴리즈란 코드 유지보수, 버젼 관리, 통보, 지원 등을 포함한다.)

재사용 가능하다는 말은 코드가 유지보수되고 불 특정 재사용자들에게 통보,안정성,지원을에 대한 보장을 제공하는 추적 시스템이 있어야 한다. 단순히 개발자가 그냥 클래스 하나 달랑 만들고 재사용 가능하다고 주장해서는 안된다.

컴포넌트가 재사용된다는 것은 컴포넌트 내부 모듈들도 모두 재사용 될 수 있다는 것이다. 컴포넌트 내 모듈들은 모두 재사용되거나, 모두 그렇지 않아야 한다. 

>*시사점 : 웹 오에스 TV는 외부 업체(CP등)대상으로 플랫폼 단위의 재사용과 릴리즈만 존재한다. 컴포넌트 단위, 즉, 서비스,공유라이브러리가 존재하지만, 특정 내부 개발자들 대상으로 재사용되므로 릴리즈 수준의 관리를 하고 있지는 않다.만일 LGSI등 원격지와 협업할 경우 어느 정도 릴리즈 관리 수준을 높일 필요가 있을 것이다.*

**CCP : 공통 폐쇄 원칙**

동일한 사유로 동일한 시점에 변경되는 모듈들을 같은 컴포넌트로 묶어라. 다른 사유로 다른 시점에 변경되는 모듈들은 다른 컴포넌트로 분리하라.
그리하여, 컴포넌트에 어떤 변화에 대한 영향이 다른 컴포넌트에 영향을 미치지 않아야 한다.

즉, 함께 수정되는 모듈들을 여러 컴포넌트로 흩어 놓지 말고 같은 컴포넌트에 넣어서 변경을 패쇄하는 것이다. 즉, 변경을 단일 컴포넌트로 제한하여 변경할 컴포넌트 수를 최소화하는 것이다.

>*시사점 : 변경이 발생할때 마다 매번 함께 수정되는 컴포넌트들은 그 내무의 모듈들을 CCP에 입각하여 컴포넌트에 재배치 할 필요가 있다*

**CRP : 공통 재사용 원칙**

컴포넌트 안의 모듈들은 함께 재사용되어야 한다 하나를 재사용하면 나머지 모두도 재사용되어야 한다. (내부 모듈들은 강하게 결합되어 있어야 한다.) 그리하여, 컴포넌트 사용자들에게 필요하지 않은 것에 의존하게 강요하지 말라.

컴포넌트 내부 모듈들은 결합 되어있어야 한다. 그렇지 않은 모듈들은 동일한 컴포넌트에 위치시키면 안된다. 

>*시사점 : 컴포넌트 내부 모듈들이 결합되어 있지 않거나, 한 모듈의 변경이 다른 모듈에 영향을 주지 않는다면 분리해야 한다. 컴포넌트 내부 파일들의 의존관계를 조사하여, 의존성이 없다면 서로 다른 컴포넌트로 분리 하자*

**컴포넌트 응집도에 대한 균형 다이어그램**

REP와 CCP는 포함 윈칙으로 컴포넌트를 크게 만든다. 반면에 CRP는 배제 원칙으로 컴포넌트를 작게 만든다. 

균형 다이어 그램은 한 원칙을 포기했을 때 감수해야할 비용을 나타낸다.

* REP(재사용성을 위한 그룹) 약화 : 재사용이 어려움
* CCP(유지보수성을 위한 그릅) 약화 : 컴포넌트들의 변경이 너무 빈번함
* CRP(불필요한 릴리즈를 피하기 위한 분리) 약화 : 불필요한 릴리즈가 너무 빈번함.

아키텍트는 균형을 이루어야 하며, 초기에는 개발 가능성이 중요해서 CCP, 나중에는 REP가 중요해 질 수 있따.

>*시사점 : 응집도를 상충되는 두 가지 관점으로 봐라 볼수 있다. 변경되는 컴포넌트 수를 줄이기 위해 함께 변경되는 코드를 같은 컴포넌트로 모을 수록 컴포넌트가 커지게 되고, 반대로 서로 강하게 결합되어 있지 않은 파일들을 같은 컴포넌트로 모으면 빈번하게 릴리즈가 발생하여 사용자에게 불필요한 영향을 주므로, 강하게 결합되어 있지 않은 파일을 분리할 수록 컴포넌트는 작아지게 된다. 정답은 없다. 아키텍트의 인싸이트가 필요하다.*

>*시사점 : CCP와 CRP가 헷갈릴수 있는데 아래의 관점을 맴핑 할 수 있을 것이다.*

* CCP : 하나의 컴포넌트는 동일한 이유로 변경되어야 한다. 그로므로, 같은 이유로 함께 자주 변경되는 코드를 모아라~
* CRP : 하나의 컴포넌트는 하나의 액터에 대해서만 책임 져야 한다. 즉, 다른 액터를 책임지는 코드는 분리하라~

## 14장 컴포넌트 결합

**ADP : 의존성 비순환 원칙 (Acyclic Dependencies Principle)**

컴포넌트간의 의존성은 비순환 방향 그래프(DAG:Directed Acyclic Graph)를 유지해야 한다. 만일 순환 의존성(dependency cycle)이 발생하면 하기와 같은 문제가 발생 한다.

* 순환 관계에 있는 컴포넌트들은 사실상 하나의 거대한 컴포넌트가 되어 동일하게 릴리즈해야 한다. 그리하여, 해당 컴포넌트 개발자들은 모두 서로 얽매이게 된다. 예를 들어, E->A, B->A, C->B 관계에서는 E는 A에 대해서만 호환되면 되는데, A->C가 되어 순환 의존성이 생기면, E에 대한 정합 및 테스트를 위해 A,B,C가 모두 필요한 상황이 된다.

* 어떤 순서로 빌드하는 것이 올바른지 알수 없다. 특히, 바이너리를 사용하기 위해 선언문을 읽어야하는 정적 언어라면 끔찍한 문제가 일어 날 수 있다.

순환 의존성을 끊고 DAG를 유지하기 위한 주요 메카니즘은 아래와 같다.

1. 의존성 역전 원칙 DIP를 적용한다. 컴포넌트 내에 인터페이스를 만들고, 다른 컴포넌트가 상속 받는다.
2. 두 컴포넌트 모두 의존하는 새로운 컴포넌트를 만든다.

소프트웨어가 성장함에 따라의존성 구조는 흐트러지며, 또 성장한다. 

**하향식(top-down) 설계**

컴포넌트는 하향식으로 설계 할 수 없다. 시스템 초기 설계 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.

컴포넌트 의존성 다이어그램은 기능을 표현하는 속성이 아니라 빌드 가능성과 유지보수성을 보여 주는 지도이다. 

* ADP원칙에 따라 순환 의존성을 관리하고, CCP원칙에 따라 함께 변경되는 요소를 최대한 하나의 컴포넌트에 배치한다. 
* 컴포넌트 의존성 그래프를 가다듬어, 자주 변경되는 컴포넌트로 부터 안정적이며 가치가 높은 컴포넌트를 보호한다.
* 시스템이 성장하면서 CRP원칙에 따라 컴포넌트를 재조합하고, 순환이 발생하면 ADP원칙을 적용한다

즉, 컴포넌트 의존성 그래프는 조금씩 흐트러지고, 또 성장한다.







